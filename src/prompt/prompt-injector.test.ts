/**
 * Tests for prompt injection mechanism
 */

import Database from "better-sqlite3";
import * as fs from "node:fs";
import * as os from "node:os";
import * as path from "node:path";
import { afterEach, beforeEach, describe, expect, it } from "vitest";

import type { AggregatedInsight, PromptAddition } from "../types/index.js";

import {
  generateBrainInsightsSkill,
  writeBrainInsightsSkill,
  generateModelSkill,
  updateAgentsFile,
  removeFromAgentsFile,
  injectInsights,
  removeInjectedInsights,
  getInjectionStatus,
} from "./prompt-injector.js";

// =============================================================================
// Test Fixtures
// =============================================================================

function createTestAddition(model: string, insightCount = 2): PromptAddition {
  return {
    model,
    section: `## Notes for ${model}`,
    priority: 100,
    content: `### Known quirks to avoid:\n\n- **Uses sed instead of read tool**\n  - Workaround: Use read tool\n\n### Effective techniques:\n\n- Specify production-ready`,
    sourceInsights: Array.from(
      { length: insightCount },
      (_, i) => `insight-${i}`
    ),
  };
}

function createTestInsight(
  overrides: Partial<AggregatedInsight> = {}
): AggregatedInsight {
  return {
    id: "test-insight-1",
    type: "quirk",
    model: "google/gemini-3-flash",
    pattern: "Uses sed instead of read tool",
    frequency: 10,
    confidence: 0.8,
    severity: "medium",
    workaround: "Use read tool",
    examples: ["node-1", "node-2"],
    firstSeen: "2026-01-01T00:00:00Z",
    lastSeen: "2026-01-25T00:00:00Z",
    promptIncluded: false,
    updatedAt: "2026-01-25T00:00:00Z",
    ...overrides,
  };
}

function setupTestDatabase(): Database.Database {
  const db = new Database(":memory:");

  // Create minimal schema for testing
  db.exec(`
    CREATE TABLE aggregated_insights (
      id TEXT PRIMARY KEY,
      type TEXT NOT NULL,
      model TEXT,
      tool TEXT,
      pattern TEXT NOT NULL,
      frequency INTEGER DEFAULT 1,
      confidence REAL,
      severity TEXT,
      workaround TEXT,
      examples TEXT,
      first_seen TEXT,
      last_seen TEXT,
      prompt_text TEXT,
      prompt_included INTEGER DEFAULT 0,
      prompt_version TEXT,
      updated_at TEXT DEFAULT (datetime('now'))
    );
  `);

  return db;
}

function insertInsight(
  db: Database.Database,
  insight: AggregatedInsight
): void {
  db.prepare(`
    INSERT INTO aggregated_insights (
      id, type, model, tool, pattern, frequency, confidence, severity,
      workaround, examples, first_seen, last_seen, prompt_included
    ) VALUES (
      @id, @type, @model, @tool, @pattern, @frequency, @confidence, @severity,
      @workaround, @examples, @firstSeen, @lastSeen, @promptIncluded
    )
  `).run({
    id: insight.id,
    type: insight.type,
    model: insight.model ?? null,
    tool: insight.tool ?? null,
    pattern: insight.pattern,
    frequency: insight.frequency,
    confidence: insight.confidence,
    severity: insight.severity,
    workaround: insight.workaround ?? null,
    examples: JSON.stringify(insight.examples),
    firstSeen: insight.firstSeen,
    lastSeen: insight.lastSeen,
    promptIncluded: insight.promptIncluded ? 1 : 0,
  });
}

// =============================================================================
// generateBrainInsightsSkill Tests
// =============================================================================

describe("generateBrainInsightsSkill", () => {
  it("should generate skill with empty additions message", () => {
    const skill = generateBrainInsightsSkill([]);

    expect(skill).toContain("---");
    expect(skill).toContain("name: brain-insights");
    expect(skill).toContain("trigger: manual");
    expect(skill).toContain("No actionable insights have been learned yet");
  });

  it("should generate skill with model insights", () => {
    const additions = [createTestAddition("google/gemini-3-flash")];
    const skill = generateBrainInsightsSkill(additions);

    expect(skill).toContain("name: brain-insights");
    expect(skill).toContain("Google Gemini 3 Flash");
    expect(skill).toContain("## Notes for google/gemini-3-flash");
    expect(skill).toContain("Uses sed instead of read tool");
    expect(skill).toContain("Generated by pi-brain");
  });

  it("should list all models in description", () => {
    const additions = [
      createTestAddition("google/gemini-3-flash"),
      createTestAddition("anthropic/claude-sonnet"),
    ];
    const skill = generateBrainInsightsSkill(additions);

    expect(skill).toContain("Google Gemini 3 Flash");
    expect(skill).toContain("Anthropic Claude Sonnet");
  });
});

// =============================================================================
// writeBrainInsightsSkill Tests
// =============================================================================

describe("writeBrainInsightsSkill", () => {
  let db: Database.Database;
  let tempDir: string;

  beforeEach(() => {
    db = setupTestDatabase();
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "pi-brain-test-"));
  });

  afterEach(() => {
    db.close();
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  it("should write skill to specified directory", () => {
    const skillDir = path.join(tempDir, "skills", "brain-insights");

    const result = writeBrainInsightsSkill(db, { skillDir });

    expect(result.success).toBeTruthy();
    expect(result.path).toBe(path.join(skillDir, "SKILL.md"));
    expect(result.path).toBeDefined();
    expect(fs.existsSync(result.path ?? "")).toBeTruthy();
  });

  it("should create parent directories if needed", () => {
    const skillDir = path.join(tempDir, "deep", "nested", "skills");

    const result = writeBrainInsightsSkill(db, { skillDir });

    expect(result.success).toBeTruthy();
    expect(fs.existsSync(path.join(skillDir, "SKILL.md"))).toBeTruthy();
  });

  it("should include insights meeting thresholds", () => {
    const skillDir = path.join(tempDir, "skills");

    // Insert insight meeting thresholds
    insertInsight(
      db,
      createTestInsight({
        id: "high-freq",
        frequency: 10,
        confidence: 0.8,
      })
    );

    const result = writeBrainInsightsSkill(db, {
      skillDir,
      minConfidence: 0.7,
      minFrequency: 5,
    });

    expect(result.success).toBeTruthy();
    expect(result.insightCount).toBeGreaterThan(0);
    expect(result.models).toContain("google/gemini-3-flash");
  });

  it("should report empty when no insights meet thresholds", () => {
    const skillDir = path.join(tempDir, "skills");

    // Insert insight not meeting thresholds
    insertInsight(
      db,
      createTestInsight({
        id: "low-freq",
        frequency: 2,
        confidence: 0.3,
      })
    );

    const result = writeBrainInsightsSkill(db, {
      skillDir,
      minConfidence: 0.7,
      minFrequency: 5,
    });

    expect(result.success).toBeTruthy();
    expect(result.insightCount).toBe(0);
    expect(result.models).toStrictEqual([]);
  });
});

// =============================================================================
// generateModelSkill Tests
// =============================================================================

describe("generateModelSkill", () => {
  let db: Database.Database;

  beforeEach(() => {
    db = setupTestDatabase();
  });

  afterEach(() => {
    db.close();
  });

  it("should return null for model with no insights", () => {
    const skill = generateModelSkill(db, "unknown/model");

    expect(skill).toBeNull();
  });

  it("should generate skill for specific model", () => {
    insertInsight(
      db,
      createTestInsight({
        model: "google/gemini-3-flash",
        frequency: 10,
        confidence: 0.8,
      })
    );

    const skill = generateModelSkill(db, "google/gemini-3-flash", {
      minConfidence: 0.5,
      minFrequency: 3,
    });

    expect(skill).not.toBeNull();
    expect(skill).toContain("Google Gemini 3 Flash");
  });
});

// =============================================================================
// updateAgentsFile Tests
// =============================================================================

describe("updateAgentsFile", () => {
  let db: Database.Database;
  let tempDir: string;
  let agentsPath: string;

  beforeEach(() => {
    db = setupTestDatabase();
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "pi-brain-agents-"));
    agentsPath = path.join(tempDir, "AGENTS.md");
  });

  afterEach(() => {
    db.close();
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  it("should return error when AGENTS.md not found", () => {
    const result = updateAgentsFile(db, { agentsFilePath: agentsPath });

    expect(result.success).toBeFalsy();
    expect(result.message).toContain("AGENTS.md not found");
  });

  it("should add section to existing AGENTS.md", () => {
    fs.writeFileSync(agentsPath, "# My AGENTS.md\n\nExisting content.\n");
    insertInsight(db, createTestInsight({ frequency: 10, confidence: 0.8 }));

    const result = updateAgentsFile(db, {
      agentsFilePath: agentsPath,
      minConfidence: 0.5,
      minFrequency: 3,
    });

    expect(result.success).toBeTruthy();
    const content = fs.readFileSync(agentsPath, "utf8");
    expect(content).toContain("Existing content");
    expect(content).toContain("<!-- pi-brain-insights -->");
    expect(content).toContain("<!-- /pi-brain-insights -->");
    expect(content).toContain("Pi-Brain Learned Insights");
  });

  it("should replace existing section in AGENTS.md", () => {
    fs.writeFileSync(
      agentsPath,
      `# My AGENTS.md

Existing content.

<!-- pi-brain-insights -->
## Old Section

Old insights here.

<!-- /pi-brain-insights -->

More content.
`
    );
    insertInsight(
      db,
      createTestInsight({
        pattern: "New insight pattern",
        frequency: 10,
        confidence: 0.8,
      })
    );

    const result = updateAgentsFile(db, {
      agentsFilePath: agentsPath,
      minConfidence: 0.5,
      minFrequency: 3,
    });

    expect(result.success).toBeTruthy();
    const content = fs.readFileSync(agentsPath, "utf8");
    expect(content).toContain("Existing content");
    expect(content).toContain("More content");
    expect(content).not.toContain("Old insights here");
    expect(content).toContain("New insight pattern");
    // Should have exactly one pair of markers
    expect(content.split("<!-- pi-brain-insights -->")).toHaveLength(2);
  });
});

// =============================================================================
// removeFromAgentsFile Tests
// =============================================================================

describe("removeFromAgentsFile", () => {
  let tempDir: string;
  let agentsPath: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "pi-brain-remove-"));
    agentsPath = path.join(tempDir, "AGENTS.md");
  });

  afterEach(() => {
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  it("should succeed when AGENTS.md not found", () => {
    const result = removeFromAgentsFile({ agentsFilePath: agentsPath });

    expect(result.success).toBeTruthy();
    expect(result.message).toContain("not found");
  });

  it("should succeed when no section present", () => {
    fs.writeFileSync(agentsPath, "# My AGENTS.md\n\nNo section here.\n");

    const result = removeFromAgentsFile({ agentsFilePath: agentsPath });

    expect(result.success).toBeTruthy();
    expect(result.message).toContain("No pi-brain section");
  });

  it("should remove section from AGENTS.md", () => {
    fs.writeFileSync(
      agentsPath,
      `# My AGENTS.md

Existing content.

<!-- pi-brain-insights -->

## Pi-Brain Learned Insights

Some insights.

<!-- /pi-brain-insights -->

More content.
`
    );

    const result = removeFromAgentsFile({ agentsFilePath: agentsPath });

    expect(result.success).toBeTruthy();
    const content = fs.readFileSync(agentsPath, "utf8");
    expect(content).toContain("Existing content");
    expect(content).toContain("More content");
    expect(content).not.toContain("<!-- pi-brain-insights -->");
    expect(content).not.toContain("Some insights");
  });
});

// =============================================================================
// injectInsights Tests
// =============================================================================

describe("injectInsights", () => {
  let db: Database.Database;
  let tempDir: string;

  beforeEach(() => {
    db = setupTestDatabase();
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "pi-brain-inject-"));
  });

  afterEach(() => {
    db.close();
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  it("should inject using skill method by default", () => {
    const skillDir = path.join(tempDir, "skills");

    const result = injectInsights(db, { skillDir });

    expect(result.success).toBeTruthy();
    expect(result.path).toContain("SKILL.md");
  });

  it("should reject unknown injection method", () => {
    const result = injectInsights(db, { method: "unknown" as never });

    expect(result.success).toBeFalsy();
    expect(result.message).toContain("Unknown injection method");
  });
});

// =============================================================================
// removeInjectedInsights Tests
// =============================================================================

describe("removeInjectedInsights", () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "pi-brain-remove-inj-"));
  });

  afterEach(() => {
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  it("should remove skill method by default", () => {
    const skillDir = path.join(tempDir, "skills");
    fs.mkdirSync(skillDir, { recursive: true });
    fs.writeFileSync(path.join(skillDir, "SKILL.md"), "test content");

    const result = removeInjectedInsights({ skillDir });

    expect(result.success).toBeTruthy();
    expect(result.message).toContain("Removed brain-insights skill");
    expect(fs.existsSync(path.join(skillDir, "SKILL.md"))).toBeFalsy();
  });

  it("should succeed when skill not found", () => {
    const skillDir = path.join(tempDir, "nonexistent");

    const result = removeInjectedInsights({ skillDir });

    expect(result.success).toBeTruthy();
    expect(result.message).toContain("not found");
  });
});

// =============================================================================
// getInjectionStatus Tests
// =============================================================================

describe("getInjectionStatus", () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "pi-brain-status-"));
  });

  afterEach(() => {
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  it("should report skill not exists when missing", () => {
    const skillDir = path.join(tempDir, "skills");

    const status = getInjectionStatus({ skillDir });

    expect(status.skillExists).toBeFalsy();
    expect(status.skillPath).toBe(path.join(skillDir, "SKILL.md"));
  });

  it("should report skill exists when present", () => {
    const skillDir = path.join(tempDir, "skills");
    fs.mkdirSync(skillDir, { recursive: true });
    fs.writeFileSync(path.join(skillDir, "SKILL.md"), "content");

    const status = getInjectionStatus({ skillDir });

    expect(status.skillExists).toBeTruthy();
  });

  it("should report AGENTS.md section status", () => {
    const agentsPath = path.join(tempDir, "AGENTS.md");
    fs.writeFileSync(
      agentsPath,
      "# AGENTS\n\n<!-- pi-brain-insights -->\ntest\n<!-- /pi-brain-insights -->"
    );

    const status = getInjectionStatus({ agentsFilePath: agentsPath });

    expect(status.agentsHasSection).toBeTruthy();
    expect(status.agentsPath).toBe(agentsPath);
  });
});
